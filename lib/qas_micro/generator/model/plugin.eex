defmodule <%= model_plugin_module %> do
  defmacro __using__(_opts) do
    quote do
      use Ecto.Schema

      import Ecto.Query
      import QasMicro.Query
      import Geo.PostGIS
      import QasMicro.Util.Sigil
      import QasMicro.Util.Helper

      alias <%= repo_module_name %>

    <%= if polymorphic do %>
      schema "abstract table: <%= table_name %>" do<%= for field <- field_schema do %>
        <%= field %><% end %><%= for relation <- relation_schema do %>
        <%= relation %><% end %>
        field :assoc_id, :integer
        <%= if(timestamp, do: "timestamps(inserted_at: :created_at, type: :integer)") %>
      end
    <% else %>
      schema "<%= table_name %>" do<%= for field <- field_schema do %>
        <%= field %><% end %><%= for relation <- relation_schema do %>
        <%= relation %><% end %>
        <%= if(timestamp, do: "timestamps(inserted_at: :created_at, type: :integer)") %>
      end
    <% end %>

      @create_fields <%= create_fields %>
      @update_fields <%= update_fields %><%= if password do %>
      @password_fields [:password, :password_confirmation]<% end %>

      def create_changeset(struct, params \\ %{}, _role \\ :visitor) do
        struct
        |> Ecto.Changeset.cast(params, @create_fields)<%= for validation <- create_validation do %>
        <%= validation %><% end %><%= if password do %>
        |> generate_password_digest()<% end %><%= if unique_number do %>
        |> generate_unique_number()<% end %><%= if geometry do %>
        |> cast_geometry()
        <% end %>
      end

    <%= for status_changeset_method <- status_changeset_methods do %>
      <%= status_changeset_method %>
    <% end %>

      def update_changeset(struct, params \\ %{}, _role \\ :visitor) do
        struct
        |> Ecto.Changeset.change()
        |> Ecto.Changeset.cast(params, @update_fields)<%= for validation <- update_validation do %>
        <%= validation %><% end %><%= if geometry do %>
        |> cast_geometry()
        <% end %>
      end

    <%= if geometry do %>
      def cast_geometry(changeset) do
        if Enum.empty?(changeset.errors) do
          lon = Ecto.Changeset.get_change(changeset, :lon)
          lat = Ecto.Changeset.get_change(changeset, :lat)

          if lon && lat do
            Ecto.Changeset.put_change(changeset, :geom, %Geo.Point{coordinates: {lon, lat}, srid: 4326})
          else
            changeset
          end
        else
          changeset
        end
      end
    <% end %>

    <%= if password do %>
      def password_changeset(struct, params \\ %{}) do
        struct
        |> Ecto.Changeset.change()
        |> Ecto.Changeset.cast(params, @password_fields)
        |> Ecto.Changeset.validate_confirmation(:password, [])
        |> check_old_password(Map.get(params, :old_password))
        |> generate_password_digest
      end

      defp check_old_password(changeset, old_password) do
        if Bcrypt.verify_pass(old_password, changeset.data.password_digest) do
          changeset
        else
          Ecto.Changeset.add_error(changeset, :password, "wrong old password")
        end
      end

      def generate_password_digest(changeset) do
        if Enum.empty?(changeset.errors) do
          plain_passwd = Ecto.Changeset.get_change(changeset, :password)
          Ecto.Changeset.put_change(changeset, :password_digest, Bcrypt.hash_pwd_salt(plain_passwd))
        else
          changeset
        end
      end
    <% end %>

    <%= if auth do %>
      def auth(input) do
        with {:ok, user} <- sign_in(input) do
          {:ok, user}
        else
          {:error, reason} ->
            {:error, reason}
        end
      end

      defp sign_in(input) do
        {password, cast_input} = Map.pop(input, :password)
        cast_input_keyword = QasMicro.Util.Helper.map_to_keyword(cast_input)

        user = Repo.get_by(<%= model_module %>, cast_input_keyword)

        if password do
          # password authenticate
          check_result =
            case user do
              nil -> Bcrypt.no_user_verify()
              _ -> Bcrypt.verify_pass(password, user.password_digest)
            end

          if check_result do
            {:ok, user}
          else
            {:error, "user does not exist or wrong password"}
          end
        else
          {:error, "user does not exist or wrong password"}
        end
      end
    <% end %>

      # return empty struct
      def new do
        %__MODULE__{}
      end

      # fields config with different
      def all_fields do
        <%= all_fields %>
      end

      def create_fields do
        <%= create_fields %>
      end

      def update_fields do
        <%= update_fields %>
      end

      # the methods used in grpc services
      def list_<%= object_name %>(common_id, _stream) do
        %{id: id} = common_id

        case Repo.get(__MODULE__, id) do
          nil ->
            nil

          result ->
            <%= Macro.camelize(application_name) %>.<%= Macro.camelize(object_name) %>.new(result)
        end
      end

      def list_<%= Inflex.pluralize(object_name) %>(params, _stream) do
        {_, ids_map} = Map.split(params, [:filter, :order, :paginate, :user])

        result =
          params
          |> Map.take([:filter, :order, :paginate])
          |> Enum.reduce(__MODULE__, plural_query_reducer(__MODULE__))
          |> ids_filter(ids_map)
          |> Repo.all

        <%= Macro.camelize(application_name) %>.<%= object_name |> Inflex.pluralize() |> Macro.camelize() %>.new(
          <%= Inflex.pluralize(object_name) %>: result
        )
      end

      def create_<%= object_name %>(create_input, _stream) do
        {input, _} = Map.split(create_input, [:user])

        new()
        |> create_changeset(input)
        |> Repo.insert
        |> case do
          {:ok, item} ->
            <%= Macro.camelize(application_name) %>.<%= Macro.camelize(object_name) %>Result.new(<%= object_name %>: item)

          {:error, changeset} ->
            <%= Macro.camelize(application_name) %>.<%= Macro.camelize(object_name) %>Result.new(errors: transform_errors(changeset))
        end
      end

      def update_<%= object_name %>(update_input, _stream) do
        %{id: id} = update_input
        {input, _} = Map.split(update_input, [:user, :id])

        record = Repo.get(<%= model_module %>, id)

        case record do
          nil ->
            <%= Macro.camelize(application_name) %>.<%= Macro.camelize(object_name) %>Result.new(errors: %{key: "not_found", message: "can not find record"})

          _ ->
            record
            |> update_changeset(input)
            |> Repo.update
            |> case do
              {:ok, item} ->
                <%= Macro.camelize(application_name) %>.<%= Macro.camelize(object_name) %>Result.new(<%= object_name %>: item)

              {:error, changeset} ->
                <%= Macro.camelize(application_name) %>.<%= Macro.camelize(object_name) %>Result.new(errors: transform_errors(changeset))
            end
        end
      end

      def delete_<%= object_name %>(common_id, _stream) do
        %{id: id} = common_id

        record = Repo.get(<%= model_module %>, id)

        case record do
          nil ->
            Common.ActionResult.new(%{status: "failed", message: "can't find record"})

          _ ->
            record
            |> Repo.delete
            |> case do
              {:ok, _} ->
                Common.ActionResult.new(%{status: "success", message: "record delete success"})

              {:error, _} ->
                Common.ActionResult.new(%{status: "failed", message: "delete failed"})
            end
        end
      end

    <%= if auth do %>
      def create_auth_<%= object_name %>(input, _stream) do
        auth_input = Map.take(input, [:name, :password])

        case auth(auth_input) do
          {:ok, result} ->
            <%= Macro.camelize(application_name) %>.Auth<%= Macro.camelize(object_name) %>.new(
              <%= object_name %>: result,
              app: "<%= application_name %>",
              model: "<%= object_name %>",
              id: result.id
            )

          {:error, _} ->
            <%= Macro.camelize(application_name) %>.Auth<%= Macro.camelize(object_name) %>.new(
              <%= object_name %>: nil,
              app: "<%= application_name %>",
              model: "<%= object_name %>",
              id: nil
            )
        end
      end
    <% end %>

      defp transform_errors(changeset) do
        changeset
        |> Ecto.Changeset.traverse_errors(&format_error/1)
        |> Enum.map(fn {key, value} ->
          %{key: key, message: value}
        end)
      end

      defp format_error({msg, opts}) do
        Enum.reduce(opts, msg, fn {key, value}, acc ->
          String.replace(acc, "%{#{key}}", to_string(value))
        end)
      end

      def paginate_with(query, pagination) do
        if is_nil(pagination) do
          query
        else
          offset = Map.get(pagination, :offset, 0)
          limit = Map.get(pagination, :limit, 10)
          from(q in query, limit: ^limit, offset: ^offset)
        end
      end

      def order_with(query, _item), do: query

      def filter_with(query, _item), do: query

      defoverridable Module.definitions_in(__MODULE__, :def)
    end
  end
end